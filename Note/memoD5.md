랜 방식

CSMA CD - Carrier Sensor Multiple Access with Collision Detection
초기 이더넷 기술로 사용된 매체의 접속을 제어하는 방식을 말함
MAC을 이용하여 충돌을 확인함. 그리고 스펙상 다중 전송이 어려웠던 시절이라
사용했던걸로 보임

CSMA CA - Avoidance
미리 충돌을 예방함

token ring - IBM의 프로토콜
권한있는 유저에게만 통신권한을 주는 방식
이 권한을 토큰이라 부르며 사용이 끝나면 다음 사용자에게 넘어감
# 4~16MB라는데 이더넷이 100mb단위인거 생각하면 느려보임

----------------------------코파일럿 정보 정리 필요-------------------------------
CSMA/CA 이후에 등장한 기술들은 무선 네트워크의 효율성과 속도를 개선하는 방향으로 발전했어. 대표적으로 다음과 같은 기술들이 있어:

🚀 1. MU-MIMO (Multi-User Multiple Input Multiple Output)
Wi-Fi 5 (802.11ac)부터 도입된 기술로, 여러 장치가 동시에 데이터를 주고받을 수 있도록 지원함.

기존 CSMA/CA 방식은 한 번에 하나의 장치만 데이터를 전송했지만, MU-MIMO는 여러 장치가 동시에 통신 가능.

이를 통해 충돌 없이 대역폭을 최대로 활용할 수 있도록 발전했어.

🔄 2. OFDMA (Orthogonal Frequency Division Multiple Access)
Wi-Fi 6 (802.11ax)에서 도입된 핵심 기술로, 데이터를 보내는 방식을 더욱 효율적으로 개선함.

기존에는 한 명의 사용자가 한 번에 전체 대역폭을 사용했지만, OFDMA는 여러 사용자가 대역폭을 나눠서 동시에 사용할 수 있도록 설계됨.

즉, 트래픽이 많아도 병목 현상이 적고 충돌 없이 원활한 통신 가능!

⚡ 3. TWT (Target Wake Time)
Wi-Fi 6(802.11ax)에서 추가된 기술로, IoT 기기 및 배터리 절약이 필요한 장치들을 위해 최적화됨.

네트워크가 필요할 때만 활성화되어 불필요한 충돌을 줄이고 전력 소모를 최소화할 수 있도록 함.

🛜 4. Full-Duplex Wireless (미래 기술)
현재 연구 중인 기술로, 무선 네트워크에서도 Full-Duplex(동시 송수신)가 가능하도록 개선하는 방식.

기존 Wi-Fi는 한 번에 하나의 방향으로만 데이터 전송 가능했지만, Full-Duplex 기술이 적용되면 충돌 없이 동시에 데이터를 송·수신할 수 있게 됨.

이 기술이 상용화되면 CSMA/CA 방식이 거의 필요 없어질 수도 있어!

💡 결론
CSMA/CA 이후 네트워크 기술들은 충돌을 줄이고 여러 사용자가 동시에 네트워크를 사용할 수 있도록 발전해왔어. 현재 Wi-Fi 6과 7에서는 MU-MIMO와 OFDMA 덕분에 더욱 효율적인 네트워크 환경이 제공되고 있고, 미래에는 Full-Duplex Wireless 기술이 더 발전할 가능성이 높아.
-----------------------------------------------------------

.class(bytecode) -> JVM -> OS
JVM (Java Virtual Machine)
위 과정은 작성된 코드가 JVM을 통해서 OS로 전달되는 모습을 설명하는 것

JIT (Just In Time) - JVM을 C언어로 컨버팅해줌

**확실하지 않음 -- 기억만 해둘것
자바에서 코드가 완성되면 자바 컴파일러를 통해서 컴파일되어 .class가 되어 바이트 형태로 JVM에 넘겨짐 이걸 JVM내의 C언어 함수를 사용하여 C로 만들어주는게 JIT이고
이 개념이 버츄얼 머신에 기여한 것

Busy Waiting - 아마 멀티쓰레드에서 Lock거는 행위 

CPython도 비슷한ㄱ걸 처리해줌

cpu 점유 방법론
1. Round Robin - Fairness를 공평하게 처리 - Time Slice하여 각 cpu에 시간할당
2. prioriry - VIP 서비스같은거 - 우선도 높은 대상에게 시간을 더 줌
   └ 단점: 우선도 높은 대상이 계속 잡고있으면 Time Slice에 문제가 생김 (Starvation) -> 해결책 - Anging 기법 - 대기시간이 길어지면 다음 우선도나 다른 대상의 우선도를 높여서 Round Robin으로 처리함
즉
3. 1 + 2을 시도하는게 Aging

race condition - 다른 코어들이 같은 자원을 관리하다 행동이 겹치는 문제가
└ 그래서 Synchronization 기법으로 Lock을 통해서 다른 코어의 접근을 미연에 방지함

Semaphore 아무튼 이런 기법들 많음
realtime os - 정확한 시간을 지켜야하는 환경에서 사용됨

yield - 코루틴에서 자주썼는데 여기서 언급된 이유가 불문임
추후 나올테니 기억해둘 것

process를 돌리는 대상 processor - cpu를 이렇게 칭함
보통 1 cpu환경에서는 각 코어가 동작하여 프로세서를 돌림

fork: 현재 프로세스 상에서 자식 프로세스를 만드는 행동

DMA Direct Memory Access - 파일을 건드릴때는 CPU가 하는게 아니라 얘가 함.

prompt
Non Prompt기법

cpu가 메모리에 접근할때 가장 속도를 많이 잡아먹힘
thread pool - 그래서 할당 할 수 있는 걸 미리 만들어 둠

프로세스간 데이터가 교환되는 상황
네트워크 프로세서와 GUI출력 프로세서간 통신
하나의 공유 메모리를 만들고 그 메모리를 같이 사용하여 통신

이걸 Client-Server 모델이라고 칭함

IPC - Inter-Process Communication - 프로세스 간 통신

---------------------------------REST-------------------------------
REST (Representational State Transfer) - 대표 상태 전송

REST의 구성 요소
1. 자원(Resource)
- 자원은 서버에 존재하는 데이터의 총칭입니다. 모든 자원은 고유의 URI(URL)을 가지며 클라이언트는 이 URI를 지정하여 해당 자원에 대해 CRUD 명령을 수행할 수 있습니다. (ex: /resource/1)

2. 행위(Verb)
- 행위는 클라이언트가 HTTP Method를 이용하여 자원을 조작하는 것을 의미합니다.

3. 표현(Representation)
- 클라이언트가 HTTP Method로 자원을 조작하면 서버가 그에 대한 응답(JSON, XML)을 보내는데 그것을 의미합니다

REST의 특징
1. 서버-클라이언트 구조(Server-Client Architecture)
- 서버는 API 제공, 클라이언트는 유저에 대한 처리를 전담하는 구조를 가지기 때문에 서버와 클라이언트의 역할을 분명하게 구분할 수 있습니다.

​

2. 무상태성(Stateless)
- HTTP를 이용하는 만큼 Stateless의 특성을 가집니다. 각각의 요청에 대한 정보를 저장하지 않고 별개의 요청으로 처리합니다. 덕분에 구현이 쉽고 서버의 부담을 덜어줄 수 있습니다.

​

3. 캐시 가능(Cacheable)
- HTTP를 사용하기 때문에 웹의 기본 인프라를 사용할 수 있습니다. 따라서 캐시 기능을 이용해 같은 URI에 대한 반복된 요청을 효율적으로 처리할 수 있습니다.

​

4. 일관된 인터페이스(Uniform Interface)
- HTTP를 사용할 수 있는 환경이라면 플랫폼에 상관없이 사용할 수 있으며 리소스의 타입에 상관 없이 같은 형태의 요청으로 처리됩니다.

​

5. 자체적인 표현 구조(Self-Descriptiveness)
- JSON, XML 등을 이용하는 메세지 구조로 해당 메세지가 무엇을, 어떤 행위를 의미하는지 직관적으로 이해할 수 있습니다.

​

6. 계층 구조(Layered System)
- 클라이언트는 대상 서버와 직접 통신하는지 아니면 중간 서버와 통신하는지 알 수 없습니다. 따라서 클라이언트와 서버의 통신 사이에 보안이나 로드 밸런싱등을 위한 중간 계층을 추가할 수 있습니다.

REST의 장단점
장점
1. 별도의 인프라 구축 필요x

- HTTP를 사용하기 때문에 별도의 인프라를 구축할 필요가 없습니다.

​

2. 클라이언트와 서버의 분리

- 클라이언트와 서버는 REST API를 통해 정보를 주고 받기 때문에 둘 간의 역할이 명확하게 분리됩니다.

​

3. 플랫폼에 독립적

- HTTP를 사용 가능한 환경이라면 플랫폼에 상관없이 사용 가능합니다.

​

4. 쉬운 사용

- 메세지가 자체적으로 무엇을 의미하는지 표현하고 있기 때문에 사용이 쉽습니다.

​

단점
1. 표준이 존재하지 않음

- 명확한 표준이 존재하지 않습니다. 따라서 REST의 특징을 따르지 않으면서 REST API로 설계되는 이상한 API가 탄생할 수 있으며 관리가 어렵습니다.

​

2. HTTP Method의 한계

- HTTP Method를 사용하기 때문에 CRUD라는 단순한 행위의 Method만 지원합니다.

​

3. RDBMS와 맞지 않음

- REST에서는 리소스를 JSON, XML등의 형태로 표현하는데 이는 RDBMS와는 맞지 않는 형태입니다. 그래서 NoSQL쪽이 더 선호되는 추세입니다.

REST API
REST의 규칙을 지키면서 만든 API를 REST API 혹은 RESTful API라고 부릅니다.
-----------------------------------------------------------------------------------

# REST랑 무슨 관계지?
RESTful service 
└ HTTP 통신 - socket 바인딩은 이 단계
└ TCP/UDP (무결성이 보장된 방식 / 그냥 쏴서 발생만 보장하는 방식)
└ IP - 흔히 아는 IP주소
└ MAC Address (Media Access Control Address)
└ 물리계층

spring - flask - LLM or HuggingFace

우리가 쓰는 일반적인 통신 2가지
Connection Oriented (연결 지향 통신) -
유용한 데이터가 전송되기 전에 통신 세션 또는 반영구적인 연결이 설정되는 통신 프로토콜
통신때 에러핸들링도 맡아줘서 계속해서 완전한 통신이 이루어져야 함 - TCP

Connectinalless - 커넥션없이 무작위로 쏨 - UDP - 보이스가 여기 많이씀.
꺠져도 어떻게든 돼서

우리가 쓸 XML용도 - 스프링 세팅

구글 클라우드 문제 - 작업 환경에서의 내 IP주소를 확인할 수 없음
NGLock? 으로 구글클라우드에 접근하여 IP주소를 캐낼 수 있음

오라클 설정
오라클 + JDK를 깔아야함
대충 Java Devleopment Kit같은데 
